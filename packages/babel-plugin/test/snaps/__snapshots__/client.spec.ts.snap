// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`should work with jsx client transform > should work with CSS Variables transform to inline style 1`] = `
"import { template as _template$ } from "essor";
const _$tmpl = _template$("<div  style=\\"--color: red;\\">Hello, World!</div>");
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with bind api 1`] = `
"import { patchAttr as _patchAttr$, template as _template$, mapNodes as _mapNodes$, bindElement as _bindElement$, memoEffect as _memoEffect$ } from "essor";
const _$tmpl = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p></div>");
const value = 1;
(() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [2]);
  _bindElement$(_$nodes[0], "value", value, _value => value = _value);
  _memoEffect$(_p$ => {
    var _v$0 = value;
    _v$0 !== _p$.a0 && _patchAttr$(_$nodes[0], "value", _p$.a0, _p$.a0 = _v$0);
    return _p$;
  }, {
    a0: undefined
  });
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with comment in JSX 1`] = `
"import { patchAttr as _patchAttr$, template as _template$, mapNodes as _mapNodes$, bindElement as _bindElement$, memoEffect as _memoEffect$ } from "essor";
const _$tmpl = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p></div>");
const value = 1;
(() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [2]);
  _bindElement$(_$nodes[0], "value", value, _value => value = _value);
  _memoEffect$(_p$ => {
    var _v$0 = value;
    _v$0 !== _p$.a0 && _patchAttr$(_$nodes[0], "value", _p$.a0, _p$.a0 = _v$0);
    return _p$;
  }, {
    a0: undefined
  });
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with concurrent mode 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div  data-concurrent></div>");
const ConcurrentMode = ({
  children
}) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => children);
  return _$el;
})();
const element = _createComponent$(ConcurrentMode, {
  "children": ["Concurrent Mode Content"]
});"
`;

exports[`should work with jsx client transform > should work with concurrent mode and suspense 1`] = `
"import { createComponent as _createComponent$, Suspense as _Suspense$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Loading...</div>");
const element = _createComponent$(ConcurrentMode, {
  "children": [_createComponent$(_Suspense$, {
    "fallback": (() => {
      const _$el = _$tmpl();
      return _$el;
    })(),
    "children": ["Concurrent Mode Suspended Content"]
  })]
});"
`;

exports[`should work with jsx client transform > should work with conditional rendering 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$ } from "essor";
const _$tmpl = _template$("<div></div>"),
  _$tmpl2 = _template$("<p>Visible Content</p>"),
  _$tmpl3 = _template$("<span>True</span>"),
  _$tmpl4 = _template$("<span>False</span>");
const isVisible = true;
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => isVisible && (() => {
    const _$el2 = _$tmpl2();
    return _$el2;
  })());
  _insert$(_$nodes[0], () => isVisible ? (() => {
    const _$el3 = _$tmpl3();
    return _$el3;
  })() : (() => {
    const _$el4 = _$tmpl4();
    return _$el4;
  })());
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with context 1`] = `
"import { createComponent as _createComponent$ } from "essor";
const ThemeContext = {
  Provider: ({
    value,
    children
  }) => children
};
const element = _createComponent$(ThemeContext.Provider, {
  "value": "dark",
  "children": ["Themed Content"]
});"
`;

exports[`should work with jsx client transform > should work with context and memo combination 1`] = `
"import { patchAttr as _patchAttr$, template as _template$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div>Memo Content</div>");
const ThemeContext = {
  Provider: ({
    value,
    children
  }) => children
};
const MemoComponent = ({
  theme
}) => (() => {
  const _$el = _$tmpl();
  return _$el;
})();
MemoComponent._memo = true;
const element = _createComponent$(ThemeContext.Provider, {
  "value": "dark",
  "children": [_createComponent$(MemoComponent, {
    "theme": "dark"
  })]
});"
`;

exports[`should work with jsx client transform > should work with context providers 1`] = `
"import { createComponent as _createComponent$ } from "essor";
const ThemeContext = {
  Provider: ({
    value,
    children
  }) => children
};
const element = _createComponent$(ThemeContext.Provider, {
  "value": "dark",
  "children": ["Themed Content"]
});"
`;

exports[`should work with jsx client transform > should work with custom hooks in components 1`] = `
"import { patchAttr as _patchAttr$, template as _template$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div>Hook Content</div>");
const useCustomHook = () => ({
  value: 'custom'
});
const Component = () => {
  const {
    value
  } = useCustomHook();
  return (() => {
    const _$el = _$tmpl();
    return _$el;
  })();
};
const element = _createComponent$(Component, {});"
`;

exports[`should work with jsx client transform > should work with dynamic class names 1`] = `
"import { patchClass as _patchClass$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Dynamic Class</div>");
const isActive = true;
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with dynamic style transform to inline style 1`] = `
"import { patchStyle as _patchStyle$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Hello, World!</div>");
const color = "red";
const style = {
  color,
  fontSize: '16px'
};
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with dynamic styles 1`] = `
"import { patchStyle as _patchStyle$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Dynamic Style</div>");
const color = 'red';
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with error boundaries 1`] = `
"import { template as _template$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div>Error occurred!</div>");
const ErrorBoundary = ({
  children
}) => {
  try {
    return children;
  } catch (error) {
    return (() => {
      const _$el = _$tmpl();
      return _$el;
    })();
  }
};
const element = _createComponent$(ErrorBoundary, {
  "children": ["Protected Content"]
});"
`;

exports[`should work with jsx client transform > should work with error boundaries2 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div  data-error-boundary></div>"),
  _$tmpl2 = _template$("<div>Error occurred!</div>");
const ErrorBoundary = ({
  children,
  fallback
}) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => children);
  _insert$(_$nodes[0], () => fallback);
  return _$el;
})();
const element = _createComponent$(ErrorBoundary, {
  "fallback": (() => {
    const _$el2 = _$tmpl2();
    return _$el2;
  })(),
  "children": ["Protected Content"]
});"
`;

exports[`should work with jsx client transform > should work with event handlers 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, delegateEvents as _delegateEvents$ } from "essor";
const _$tmpl = _template$("<button>Click me</button>");
const handleClick = () => console.log('clicked');
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _$nodes[0]["_$click"] = handleClick;
  return _$el;
})();
_delegateEvents$(["click"]);"
`;

exports[`should work with jsx client transform > should work with forwardRef and memo 1`] = `
"import { patchAttr as _patchAttr$, template as _template$, mapNodes as _mapNodes$, insert as _insert$, memoEffect as _memoEffect$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div>Forward Ref Memo:</div>");
const ForwardRefMemoComponent = React.memo(React.forwardRef((props, ref) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => props.value);
  _memoEffect$(_p$ => {
    var _v$0 = ref;
    _v$0 !== _p$.r0 && _patchAttr$(_$nodes[0], "ref", _p$.r0, _p$.r0 = _v$0);
    return _p$;
  }, {
    r0: undefined
  });
  return _$el;
})()));
const element = _createComponent$(ForwardRefMemoComponent, {
  "value": 42,
  "ref": React.createRef()
});"
`;

exports[`should work with jsx client transform > should work with forwardRef components 1`] = `
"import { patchAttr as _patchAttr$, template as _template$, mapNodes as _mapNodes$, insert as _insert$, memoEffect as _memoEffect$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div></div>");
const ForwardRefComponent = ({
  children
}, ref) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => children);
  _memoEffect$(_p$ => {
    var _v$0 = ref;
    _v$0 !== _p$.r0 && _patchAttr$(_$nodes[0], "ref", _p$.r0, _p$.r0 = _v$0);
    return _p$;
  }, {
    r0: undefined
  });
  return _$el;
})();
const element = _createComponent$(ForwardRefComponent, {
  "children": ["Forward Ref Content"]
});"
`;

exports[`should work with jsx client transform > should work with fragments and keys and values 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$, Fragment as _Fragment$ } from "essor";
const _$tmpl = _template$("<div></div>");
const val = 'test';
const Children = ({
  children
}) => {
  return (() => {
    const _$el = _$tmpl();
    const _$nodes = _mapNodes$(_$el, [1]);
    _insert$(_$nodes[0], () => children);
    return _$el;
  })();
};
const element = _createComponent$(_Fragment$, {
  "children": [val, _createComponent$(Children, {}), "First", "Second"]
});"
`;

exports[`should work with jsx client transform > should work with head management 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<head></head>"),
  _$tmpl2 = _template$("<meta  name=\\"description\\" content=\\"Page description\\"/>");
const Head = ({
  children
}) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => children);
  return _$el;
})();
const element = _createComponent$(Head, {
  "children": ["Page Title", (() => {
    const _$el2 = _$tmpl2();
    return _$el2;
  })()]
});"
`;

exports[`should work with jsx client transform > should work with lazy components 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div  data-lazy></div>");
const LazyComponent = ({
  children
}) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => children);
  return _$el;
})();
LazyComponent._lazy = true;
const element = _createComponent$(LazyComponent, {
  "children": ["Lazy Content"]
});"
`;

exports[`should work with jsx client transform > should work with list rendering 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, patchAttr as _patchAttr$, memoEffect as _memoEffect$ } from "essor";
const _$tmpl = _template$("<ul></ul>"),
  _$tmpl2 = _template$("<li></li>");
const items = ['Item 1', 'Item 2', 'Item 3'];
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => items.map((item, index) => (() => {
    const _$el2 = _$tmpl2();
    const _$nodes2 = _mapNodes$(_$el2, [1]);
    _insert$(_$nodes2[0], () => item);
    _memoEffect$(_p$ => {
      var _v$0 = index;
      _v$0 !== _p$.k0 && _patchAttr$(_$nodes2[0], "key", _p$.k0, _p$.k0 = _v$0);
      return _p$;
    }, {
      k0: undefined
    });
    return _$el2;
  })()));
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with memo and custom comparison 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div>Memo:</div>");
const MemoComponent = ({
  value
}) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => value);
  return _$el;
})();
MemoComponent._memo = true;
MemoComponent._compare = (prev, next) => prev.value === next.value;
const element = _createComponent$(MemoComponent, {
  "value": 42
});"
`;

exports[`should work with jsx client transform > should work with multiple contexts 1`] = `
"import { createComponent as _createComponent$ } from "essor";
const ThemeContext = {
  Provider: ({
    value,
    children
  }) => children
};
const UserContext = {
  Provider: ({
    value,
    children
  }) => children
};
const cla = class {
  static a = 1;
  static b = 2;
  static c = 3;
  static d = 4;
  static e = 5;
};
const element = _createComponent$(ThemeContext.Provider, {
  "value": "dark",
  "children": [_createComponent$(UserContext.Provider, {
    "value": {
      name: 'John'
    },
    "v1": undefined,
    "v2": null,
    "v3": true,
    "v4": false,
    "v5": 1,
    "v6": 1.1,
    "v7": "1",
    "v8": Symbol('1'),
    "v9": cla,
    "v10": new Date(),
    "children": ["Nested Context Content"]
  })]
});"
`;

exports[`should work with jsx client transform > should work with multiple event handlers 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, addEventListener as _addEventListener$, delegateEvents as _delegateEvents$ } from "essor";
const _$tmpl = _template$("<div>Multiple Events</div>");
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _$nodes[0]["_$click"] = () => console.log('clicked');
  _addEventListener$(_$nodes[0], "mouseenter", () => console.log('mouse enter'));
  _addEventListener$(_$nodes[0], "mouseleave", () => console.log('mouse leave'));
  return _$el;
})();
_delegateEvents$(["click"]);"
`;

exports[`should work with jsx client transform > should work with nested components and props 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div>Name:<!>, Age:</div>"),
  _$tmpl2 = _template$("<div></div>");
const Child = ({
  name,
  age
}) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1, 3]);
  _insert$(_$nodes[0], () => name, _$nodes[1]);
  _insert$(_$nodes[0], () => age);
  return _$el;
})();
const Parent = () => (() => {
  const _$el2 = _$tmpl2();
  const _$nodes2 = _mapNodes$(_$el2, [1]);
  _insert$(_$nodes2[0], _createComponent$(Child, {
    "name": "John",
    "age": 25
  }));
  _insert$(_$nodes2[0], _createComponent$(Child, {
    "name": "Jane",
    "age": 23
  }));
  return _$el2;
})();"
`;

exports[`should work with jsx client transform > should work with portal components 1`] = `
"import { patchAttr as _patchAttr$, template as _template$, mapNodes as _mapNodes$, insert as _insert$, memoEffect as _memoEffect$, createComponent as _createComponent$, Portal as _Portal$ } from "essor";
const _$tmpl = _template$("<div></div>");
const Portal = ({
  children,
  target
}) => {
  return (() => {
    const _$el = _$tmpl();
    const _$nodes = _mapNodes$(_$el, [1]);
    _insert$(_$nodes[0], () => children);
    _memoEffect$(_p$ => {
      var _v$0 = target;
      _v$0 !== _p$.d0 && _patchAttr$(_$nodes[0], "data-portal-target", _p$.d0, _p$.d0 = _v$0);
      return _p$;
    }, {
      d0: undefined
    });
    return _$el;
  })();
};
const element = _createComponent$(_Portal$, {
  "target": "modal",
  "children": ["Modal Content"]
});"
`;

exports[`should work with jsx client transform > should work with portals and ref forwarding 1`] = `
"import { patchAttr as _patchAttr$, template as _template$, mapNodes as _mapNodes$, insert as _insert$, memoEffect as _memoEffect$, createComponent as _createComponent$, Portal as _Portal$ } from "essor";
const _$tmpl = _template$("<div></div>");
const Portal = ({
  children,
  target
}, ref) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => children);
  _memoEffect$(_p$ => {
    var _v$0 = ref,
      _v$1 = target;
    _v$0 !== _p$.r0 && _patchAttr$(_$nodes[0], "ref", _p$.r0, _p$.r0 = _v$0);
    _v$1 !== _p$.d1 && _patchAttr$(_$nodes[0], "data-portal-target", _p$.d1, _p$.d1 = _v$1);
    return _p$;
  }, {
    r0: undefined,
    d1: undefined
  });
  return _$el;
})();
const element = _createComponent$(_Portal$, {
  "target": "modal",
  "ref": React.createRef(),
  "children": ["Modal Content with Ref"]
});"
`;

exports[`should work with jsx client transform > should work with refs 1`] = `
"import { patchAttr as _patchAttr$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Reference Element</div>");
const myRef = {
  current: null
};
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with static style transform to inline style 1`] = `
"import { template as _template$ } from "essor";
const _$tmpl = _template$("<div  style=\\"color:red;fontSize:16px;\\">Hello, World!</div>");
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > should work with strict mode 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _$tmpl = _template$("<div  data-strict></div>");
const StrictMode = ({
  children
}) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => children);
  return _$el;
})();
const element = _createComponent$(StrictMode, {
  "children": ["Strict Mode Content"]
});"
`;

exports[`should work with jsx client transform > should work with strict mode and error boundary 1`] = `
"import { createComponent as _createComponent$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Error occurred!</div>");
const element = _createComponent$(StrictMode, {
  "children": [_createComponent$(ErrorBoundary, {
    "fallback": (() => {
      const _$el = _$tmpl();
      return _$el;
    })(),
    "children": ["Strict Mode Protected Content"]
  })]
});"
`;

exports[`should work with jsx client transform > should work with suspense and error boundary combination 1`] = `
"import { createComponent as _createComponent$, Suspense as _Suspense$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Error occurred!</div>"),
  _$tmpl2 = _template$("<div>Loading...</div>");
const element = _createComponent$(ErrorBoundary, {
  "fallback": (() => {
    const _$el = _$tmpl();
    return _$el;
  })(),
  "children": [_createComponent$(_Suspense$, {
    "fallback": (() => {
      const _$el2 = _$tmpl2();
      return _$el2;
    })(),
    "children": ["Protected and Suspended Content"]
  })]
});"
`;

exports[`should work with jsx client transform > should work with suspense and lazy loading 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$, Suspense as _Suspense$ } from "essor";
const _$tmpl = _template$("<div  data-lazy></div>"),
  _$tmpl2 = _template$("<div>Loading...</div>");
const LazyComponent = ({
  children
}) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => children);
  return _$el;
})();
LazyComponent._lazy = true;
const element = _createComponent$(_Suspense$, {
  "fallback": (() => {
    const _$el2 = _$tmpl2();
    return _$el2;
  })(),
  "children": ["Lazy Content"]
});"
`;

exports[`should work with jsx client transform > should work with suspense boundaries 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$, Suspense as _Suspense$ } from "essor";
const _$tmpl = _template$("<div  data-suspense></div>"),
  _$tmpl2 = _template$("<div>Loading...</div>");
const Suspense = ({
  children,
  fallback
}) => (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], () => children);
  _insert$(_$nodes[0], () => fallback);
  return _$el;
})();
const element = _createComponent$(_Suspense$, {
  "fallback": (() => {
    const _$el2 = _$tmpl2();
    return _$el2;
  })(),
  "children": ["Content"]
});"
`;

exports[`should work with jsx client transform > transforms JSX element with JSX fragment 1`] = `
"import { createComponent as _createComponent$, Fragment as _Fragment$ } from "essor";
const element = _createComponent$(_Fragment$, {
  "children": ["Paragraph 1", "Paragraph 2"]
});"
`;

exports[`should work with jsx client transform > transforms JSX element with JSX fragment as children 1`] = `
"import { createComponent as _createComponent$, Fragment as _Fragment$, template as _template$, mapNodes as _mapNodes$, insert as _insert$ } from "essor";
const _$tmpl = _template$("<div></div>");
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _insert$(_$nodes[0], _createComponent$(_Fragment$, {
    "children": ["Paragraph 1", "Paragraph 2"]
  }));
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with SVG tags 1`] = `
"import { template as _template$ } from "essor";
const _$tmpl = _template$("<svg><circle  cx=\\"50\\" cy=\\"50\\" r=\\"40\\" stroke=\\"black\\" stroke-width=\\"3\\" fill=\\"red\\"></circle></svg>");
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with attributes 1`] = `
"import { template as _template$ } from "essor";
const _$tmpl = _template$("<div  id=\\"myId\\" class=\\"myClass\\">Hello, World!</div>");
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with boolean attribute 1`] = `
"import { template as _template$ } from "essor";
const _$tmpl = _template$("<input  disabled/>");
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with children 1`] = `
"import { template as _template$ } from "essor";
const _$tmpl = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p></div>");
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with class and style attributes 1`] = `
"import { patchClass as _patchClass$, patchStyle as _patchStyle$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Hello, World!</div>");
const hasClass = true;
const style = {
  color: 'red',
  fontSize: '16px'
};
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with conditional attributes 1`] = `
"import { patchClass as _patchClass$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Hello, World!</div>");
const hasClass = true;
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with function components 1`] = `
"import { createComponent as _createComponent$, template as _template$, mapNodes as _mapNodes$, insert as _insert$ } from "essor";
const _$tmpl = _template$("<div><div></div></div>");
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1, 2]);
  _insert$(_$nodes[0], _createComponent$(MyComponent, {
    "text": "Component 1"
  }), _$nodes[1]);
  _insert$(_$nodes[1], _createComponent$(MyComponent, {
    "text": "Component 2"
  }));
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with null and undefined attributes 1`] = `
"import { patchClass as _patchClass$, template as _template$, mapNodes as _mapNodes$, patchAttr as _patchAttr$, memoEffect as _memoEffect$ } from "essor";
const _$tmpl = _template$("<div>Hello, World!</div>");
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1]);
  _patchAttr$(_$nodes[0], "id", null);
  _memoEffect$(_p$ => {
    var _v$0 = undefined;
    _v$0 !== _p$.c0 && _patchClass$(_$nodes[0], _p$.c0, _p$.c0 = _v$0);
    return _p$;
  }, {
    c0: undefined
  });
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with null and undefined children 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$ } from "essor";
const _$tmpl = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p></div>");
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1, 2, 4]);
  _insert$(_$nodes[0], () => null, _$nodes[1]);
  _insert$(_$nodes[0], () => undefined, _$nodes[2]);
  _insert$(_$nodes[0], () => false, _$nodes[2]);
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with null and undefined in expressions 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$ } from "essor";
const _$tmpl = _template$("<div><p>'s Profile</p><p>Paragraph 2</p></div>");
const name = null;
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1, 2, 3, 4]);
  _insert$(_$nodes[1], () => name, _$nodes[2]);
  _insert$(_$nodes[0], () => undefined, _$nodes[3]);
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with self-closing tags 1`] = `
"import { template as _template$ } from "essor";
const _$tmpl = _template$("<div><img  src=\\"image.jpg\\" alt=\\"Image 1\\"/><img  src=\\"image.jpg\\" alt=\\"Image 2\\"/></div>");
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with spread attributes 1`] = `
"import { patchAttr as _patchAttr$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Hello, World!</div>");
const props = {
  id: 'myId',
  class: 'myClass'
};
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms JSX element with style attribute 1`] = `
"import { patchStyle as _patchStyle$, template as _template$ } from "essor";
const _$tmpl = _template$("<div>Hello, World!</div>");
const style = {
  color: 'red',
  fontSize: '16px'
};
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms client JSX element with dynamic expressions 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$ } from "essor";
const _$tmpl = _template$("<div>Hello,<!>!</div>");
const name = 'John';
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1, 3]);
  _insert$(_$nodes[0], () => name, _$nodes[1]);
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms client JSX element with multiple dynamic expressions 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$ } from "essor";
const _$tmpl = _template$("<div>Hello,<!>!<p>'s Profile<span>is a developer.<!>is a designer.</span></p></div>");
const name = 'John';
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [1, 3, 5, 6, 7, 8, 9]);
  _insert$(_$nodes[0], () => name, _$nodes[1]);
  _insert$(_$nodes[2], () => name, _$nodes[3]);
  _insert$(_$nodes[4], () => name, _$nodes[5]);
  _insert$(_$nodes[4], () => name, _$nodes[6]);
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms client JSX element with nested expressions and children 1`] = `
"import { template as _template$, mapNodes as _mapNodes$, insert as _insert$, patchAttr as _patchAttr$, memoEffect as _memoEffect$ } from "essor";
const _$tmpl = _template$("<div><p>'s Profile</p><ul></ul></div>"),
  _$tmpl2 = _template$("<li>Item</li>");
const name = 'John';
const element = (() => {
  const _$el = _$tmpl();
  const _$nodes = _mapNodes$(_$el, [2, 3, 4]);
  _insert$(_$nodes[0], () => name, _$nodes[1]);
  _insert$(_$nodes[2], () => Array.from({
    length: 3
  }, (_, i) => (() => {
    const _$el2 = _$tmpl2();
    const _$nodes2 = _mapNodes$(_$el2, [1]);
    _insert$(_$nodes2[0], () => i + 1);
    _memoEffect$(_p$ => {
      var _v$0 = i;
      _v$0 !== _p$.k0 && _patchAttr$(_$nodes2[0], "key", _p$.k0, _p$.k0 = _v$0);
      return _p$;
    }, {
      k0: undefined
    });
    return _$el2;
  })()));
  return _$el;
})();"
`;

exports[`should work with jsx client transform > transforms simple JSX element 1`] = `
"import { template as _template$ } from "essor";
const _$tmpl = _template$("<div>Hello, World!</div>");
const element = (() => {
  const _$el = _$tmpl();
  return _$el;
})();"
`;
