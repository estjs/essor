// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`jsx props transform > should not work with array props 1`] = `
"function testFunction([prop1, prop2], otherProps) {
  return <div prop1={prop1} prop2={prop2}>{otherProps}</div>;
}"
`;

exports[`jsx props transform > should not work with not pattern props 1`] = `
"function testFunction(prop1, prop2) {
  return <div prop1={prop1} prop2={prop2} />;
}"
`;

exports[`jsx props transform > should replace function parameter with "props" 1`] = `
"function testFunction({
  prop1: __props.prop1,
  prop2: __props.prop2
}) {
  return <div prop1={__props.prop1} prop2={__props.prop2} />;
}"
`;

exports[`jsx props transform > should replace function parameter with 'props' when it's an object 1`] = `
"function testFunction({
  prop1: __props.prop1,
  prop2: __props.prop2
}, otherProps) {
  return <div prop1={__props.prop1} prop2={__props.prop2}>{otherProps}</div>;
}"
`;

exports[`jsx props transform > should work just rest props 1`] = `
"function testFunction(__props) {
  return <div prop1={restProps.$prop1} prop2={restProps.prop2} rest={{
    ...restProps
  }} />;
}"
`;

exports[`jsx props transform > should work with array destructuring in object pattern 1`] = `
"function testFunction({
  items: [first, second]
}) {
  return <div first={first} second={second} />;
}"
`;

exports[`jsx props transform > should work with arrow functions in class properties 1`] = `
"class TestClass {
  handler = ({
    prop1: __props.prop1,
    prop2: __props.prop2
  }) => {
    return <div prop1={__props.prop1} prop2={__props.prop2} />;
  };
}"
`;

exports[`jsx props transform > should work with async functions 1`] = `
"async function testFunction({
  prop1: __props.prop1,
  prop2: __props.prop2
}) {
  const result = await someAsyncOperation();
  return <div prop1={__props.prop1} prop2={__props.prop2} result={result} />;
}"
`;

exports[`jsx props transform > should work with async generator functions 1`] = `
"async function* testFunction({
  prop1: __props.prop1,
  prop2: __props.prop2
}) {
  return <div prop2={__props.prop2} />;
}"
`;

exports[`jsx props transform > should work with class methods 1`] = `
"class TestClass {
  method({
    prop1,
    prop2
  }) {
    return <div prop1={prop1} prop2={prop2} />;
  }
}"
`;

exports[`jsx props transform > should work with complex nested patterns 1`] = `
"function testFunction({
  user: {
    name: __props.user.name,
    contacts: [primary = {}, ...others],
    settings: {
      theme = 'light',
      ...otherSettings
    } = {}
  }
}) {
  return <div name={__props.user.name} primary={primary} others={others} theme={theme} settings={otherSettings} />;
}"
`;

exports[`jsx props transform > should work with computed property names 1`] = `
"function testFunction({
  [computedProp]: __props.computedProp
}) {
  return <div prop={__props.computedProp} />;
}"
`;

exports[`jsx props transform > should work with deep props 1`] = `
"function testFunction({
  prop1: {
    prop2: {
      prop3: {
        prop4: __props.prop1.prop2.prop3.prop4,
        prop5: __props.prop1.prop2.prop3.prop5
      }
    }
  }
}) {
  return <div prop4={__props.prop1.prop2.prop3.prop4} prop5={__props.prop1.prop2.prop3.prop5} />;
}"
`;

exports[`jsx props transform > should work with default values 1`] = `
"function testFunction({
  prop1 = 'default1',
  prop2 = 42
}) {
  return <div prop1={prop1} prop2={prop2} />;
}"
`;

exports[`jsx props transform > should work with function parameters 1`] = `
"function testFunction({
  callback = () => {}
}) {
  return <button onClick={callback}>Click me</button>;
}"
`;

exports[`jsx props transform > should work with generator functions 1`] = `
"function* testFunction({
  prop1,
  prop2
}) {
  yield <div prop1={prop1} />;
  yield <div prop2={prop2} />;
}"
`;

exports[`jsx props transform > should work with multiple parameters including object pattern 1`] = `
"function testFunction(first, {
  prop1,
  prop2
}, last) {
  return <div first={first} prop1={prop1} prop2={prop2} last={last} />;
}"
`;

exports[`jsx props transform > should work with nested destructuring and defaults 1`] = `
"function testFunction({
  user: {
    name = 'John',
    age = 25
  } = {}
}) {
  return <div name={name} age={age} />;
}"
`;

exports[`jsx props transform > should work with nested function declarations 1`] = `
"function outer() {
  function inner({
    prop1: __props.prop1,
    prop2: __props.prop2
  }) {
    return <div prop1={__props.prop1} prop2={__props.prop2} />;
  }
  return inner;
}"
`;

exports[`jsx props transform > should work with nested function declarations with rest props 1`] = `
"function outer() {
  function inner(__props) {
    const restProps = _reactive$({
      prop1: __props.prop1,
      prop2: __props.prop2
    });
    return <div prop1={__props.prop1} prop2={__props.prop2} rest={{
      ...restProps
    }} />;
  }
  return inner;
}"
`;

exports[`jsx props transform > should work with object method shorthand 1`] = `
"const obj = {
  method({
    prop1,
    prop2
  }) {
    return <div prop1={prop1} prop2={prop2} />;
  }
};"
`;

exports[`jsx props transform > should work with rest pattern props 1`] = `
"function testFunction(__props) {
  const restProps = _reactive$({
    prop1: __props.prop1,
    prop2: __props.prop2
  });
  return <div prop1={__props.prop1} prop2={__props.prop2} {...restProps} />;
}"
`;

exports[`jsx props transform > should work with rest value props 1`] = `
"function testFunction(__props) {
  const restProps = _reactive$({
    prop1: __props.prop1,
    prop2: __props.prop2
  });
  return <div prop1={__props.prop1} prop2={__props.prop2} rest={{
    ...restProps
  }} />;
}"
`;
