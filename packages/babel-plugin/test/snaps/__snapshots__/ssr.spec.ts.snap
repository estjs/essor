// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`jsx SSR transform > should work with CSS-in-JS in SSR 1`] = `
"import { patchClass as _patchClass$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, memoEffect as _memoEffect$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-styled></div>"),
  _tmpl$2 = _template$("Styled Content");
const StyledComponent = ({
  className,
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  _memoEffect$(_p$ => {
    var _v$0 = className;
    _v$0 !== _p$.c0 && _patchClass$(_nodes[0], _p$.c0, _p$.c0 = _v$0);
    return _p$;
  }, {
    c0: undefined
  });
  return _el;
})();
const element = _createComponent$(StyledComponent, {
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()],
  "class": "generated-class"
});"
`;

exports[`jsx SSR transform > should work with async data in SSR 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div></div>");
const AsyncComponent = async ({
  data
}) => {
  const result = await data;
  return (() => {
    const _el = _tmpl$();
    const _nodes = _mapNodes$(_el, [1]);
    _insert$(_nodes[0], () => result);
    return _el;
  })();
};
const element = _createComponent$(AsyncComponent, {
  get data() {
    return Promise.resolve('async content');
  }
});"
`;

exports[`jsx SSR transform > should work with conditional rendering in SSR 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div></div>"),
  _tmpl$2 = _template$("<p>Visible Content</p>"),
  _tmpl$3 = _template$("<span>True</span>"),
  _tmpl$4 = _template$("<span>False</span>");
const isVisible = true;
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => isVisible && (() => {
    const _el2 = _tmpl$2();
    return _el2;
  })());
  _insert$(_nodes[0], () => isVisible ? (() => {
    const _el3 = _tmpl$3();
    return _el3;
  })() : (() => {
    const _el4 = _tmpl$4();
    return _el4;
  })());
  return _el;
})();"
`;

exports[`jsx SSR transform > should work with context in SSR 1`] = `
"import { createComponent as _createComponent$, getElement as _template$ } from "essor";
const _tmpl$ = _template$("<div  data-theme=\\"dark\\">Themed Content</div>");
const ThemeContext = {
  Provider: ({
    value,
    children
  }) => children
};
const element = _createComponent$(ThemeContext.Provider, {
  "value": "dark",
  "children": [(() => {
    const _el = _tmpl$();
    return _el;
  })()]
});"
`;

exports[`jsx SSR transform > should work with data fetching in SSR 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-ssr-data></div>");
const DataComponent = ({
  data
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => JSON.stringify(data));
  return _el;
})();
const element = _createComponent$(DataComponent, {
  "data": {
    key: 'value'
  }
});"
`;

exports[`jsx SSR transform > should work with error handling in SSR 1`] = `
"import { createComponent as _createComponent$, getElement as _template$ } from "essor";
const _tmpl$ = _template$("<div>Protected Content</div>"),
  _tmpl$2 = _template$("<div>Error Page</div>");
const ErrorBoundary = ({
  fallback,
  children
}) => {
  try {
    return children;
  } catch (error) {
    return fallback;
  }
};
const element = _createComponent$(ErrorBoundary, {
  get fallback() {
    return (() => {
      const _el2 = _tmpl$2();
      return _el2;
    })();
  },
  "children": [(() => {
    const _el = _tmpl$();
    return _el;
  })()]
});"
`;

exports[`jsx SSR transform > should work with event handlers in SSR 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, delegateEvents as _delegateEvents$ } from "essor";
const _tmpl$ = _template$("<button>Click me</button>");
const handleClick = () => console.log('clicked');
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _nodes[0]["$click"] = handleClick;
  return _el;
})();
_delegateEvents$(["click"]);"
`;

exports[`jsx SSR transform > should work with head management in SSR 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<head  data-ssr></head>"),
  _tmpl$2 = _template$("<title>Page Title</title>"),
  _tmpl$3 = _template$("<meta  name=\\"description\\" content=\\"Page description\\"/>");
const Head = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(Head, {
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })(), (() => {
    const _el3 = _tmpl$3();
    return _el3;
  })()]
});"
`;

exports[`jsx SSR transform > should work with hydration attributes 1`] = `
"import { getElement as _template$ } from "essor";
const _tmpl$ = _template$("<div  data-hydrate=\\"true\\">Hydration Content</div>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx SSR transform > should work with list rendering in SSR 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, patchAttr as _patchAttr$, memoEffect as _memoEffect$ } from "essor";
const _tmpl$ = _template$("<ul></ul>"),
  _tmpl$2 = _template$("<li></li>");
const items = ['Item 1', 'Item 2', 'Item 3'];
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => items.map((item, index) => (() => {
    const _el2 = _tmpl$2();
    const _nodes2 = _mapNodes$(_el2, [1]);
    _insert$(_nodes2[0], () => item);
    _memoEffect$(_p$ => {
      var _v$0 = index;
      _v$0 !== _p$.k0 && _patchAttr$(_nodes2[0], "key", _p$.k0, _p$.k0 = _v$0);
      return _p$;
    }, {
      k0: undefined
    });
    return _el2;
  })()));
  return _el;
})();"
`;

exports[`jsx SSR transform > should work with nested components and props in SSR 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div>Name:<!>, Age:</div>"),
  _tmpl$2 = _template$("<div></div>");
const Child = ({
  name,
  age
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 3]);
  _insert$(_nodes[0], () => name, _nodes[1]);
  _insert$(_nodes[0], () => age);
  return _el;
})();
const Parent = () => (() => {
  const _el2 = _tmpl$2();
  const _nodes2 = _mapNodes$(_el2, [1]);
  _insert$(_nodes2[0], () => _createComponent$(Child, {
    "name": "John",
    "age": 25
  }));
  _insert$(_nodes2[0], () => _createComponent$(Child, {
    "name": "Jane",
    "age": 23
  }));
  return _el2;
})();"
`;

exports[`jsx SSR transform > should work with streaming SSR 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, patchAttr as _patchAttr$, memoEffect as _memoEffect$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div></div>"),
  _tmpl$2 = _template$("<div></div>");
const StreamingComponent = ({
  chunks
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => chunks.map((chunk, index) => (() => {
    const _el2 = _tmpl$2();
    const _nodes2 = _mapNodes$(_el2, [1]);
    _insert$(_nodes2[0], () => chunk);
    _memoEffect$(_p$ => {
      var _v$0 = index,
        _v$1 = index;
      _v$0 !== _p$.k0 && _patchAttr$(_nodes2[0], "key", _p$.k0, _p$.k0 = _v$0);
      _v$1 !== _p$.d1 && _patchAttr$(_nodes2[0], "data-chunk", _p$.d1, _p$.d1 = _v$1);
      return _p$;
    }, {
      k0: undefined,
      d1: undefined
    });
    return _el2;
  })()));
  return _el;
})();
const element = _createComponent$(StreamingComponent, {
  "chunks": ['chunk1', 'chunk2']
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and context 1`] = `
"import { createComponent as _createComponent$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-context></div>"),
  _tmpl$2 = _template$("<div>Streaming Context Content</div>");
const StreamingContext = ({
  value,
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => _createComponent$(ThemeContext.Provider, {
    get value() {
      return value;
    },
    "children": [children]
  }));
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(StreamingContext, {
  "value": "dark",
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and custom hooks 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-hook></div>");
const useStreamingHook = () => ({
  value: 'streaming'
});
const StreamingHook = () => {
  const {
    value
  } = useStreamingHook();
  return (() => {
    const _el = _tmpl$();
    const _nodes = _mapNodes$(_el, [1]);
    _insert$(_nodes[0], () => value);
    return _el;
  })();
};
const element = _createComponent$(StreamingHook, {});"
`;

exports[`jsx SSR transform > should work with streaming SSR and data fetching 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-data></div>"),
  _tmpl$2 = _template$("<div>Loading data...</div>"),
  _tmpl$3 = _template$("<div>Data Content</div>");
const StreamingData = ({
  data,
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => data ? children : (() => {
    const _el2 = _tmpl$2();
    return _el2;
  })());
  return _el;
})();
const element = _createComponent$(StreamingData, {
  "data": {
    key: 'value'
  },
  "children": [(() => {
    const _el3 = _tmpl$3();
    return _el3;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and dynamic imports 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-dynamic></div>"),
  _tmpl$2 = _template$("<div>Loading...</div>");
const StreamingDynamic = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(Suspense, {
  get fallback() {
    return (() => {
      const _el2 = _tmpl$2();
      return _el2;
    })();
  },
  "children": [_createComponent$(StreamingDynamic, {
    "children": [import('./Component')]
  })]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and error boundaries 1`] = `
"import { createComponent as _createComponent$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-error></div>"),
  _tmpl$2 = _template$("<div>Protected Streaming Content</div>"),
  _tmpl$3 = _template$("<div>Error occurred!</div>");
const StreamingErrorBoundary = ({
  children,
  fallback
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => _createComponent$(ErrorBoundary, {
    get fallback() {
      return fallback;
    },
    "children": [children]
  }));
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(StreamingErrorBoundary, {
  get fallback() {
    return (() => {
      const _el3 = _tmpl$3();
      return _el3;
    })();
  },
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and error boundaries 2`] = `
"import { createComponent as _createComponent$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-error-boundary></div>"),
  _tmpl$2 = _template$("<div>Protected Content</div>"),
  _tmpl$3 = _template$("<div>Error occurred!</div>");
const StreamingErrorBoundary = ({
  children,
  fallback
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => _createComponent$(ErrorBoundary, {
    get fallback() {
      return fallback;
    },
    "children": [children]
  }));
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(StreamingErrorBoundary, {
  get fallback() {
    return (() => {
      const _el3 = _tmpl$3();
      return _el3;
    })();
  },
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and error handling 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-error></div>"),
  _tmpl$2 = _template$("<div>Error:</div>"),
  _tmpl$3 = _template$("<div>Streaming Content</div>");
const StreamingError = ({
  error,
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => error ? (() => {
    const _el2 = _tmpl$2();
    const _nodes2 = _mapNodes$(_el2, [1]);
    _insert$(_nodes2[0], () => error.message);
    return _el2;
  })() : children);
  return _el;
})();
const element = _createComponent$(StreamingError, {
  "error": null,
  "children": [(() => {
    const _el3 = _tmpl$3();
    return _el3;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and forwardRef 1`] = `
"import { patchAttr as _patchAttr$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, memoEffect as _memoEffect$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-forward></div>"),
  _tmpl$2 = _template$("<div>Streaming Forward Ref Content</div>");
const StreamingForwardRef = React.forwardRef((props, ref) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => props.children);
  _memoEffect$(_p$ => {
    var _v$0 = ref;
    _v$0 !== _p$.r0 && _patchAttr$(_nodes[0], "ref", _p$.r0, _p$.r0 = _v$0);
    return _p$;
  }, {
    r0: undefined
  });
  return _el;
})());
const element = _createComponent$(StreamingForwardRef, {
  get ref() {
    return React.createRef();
  },
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and hydration 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-hydration></div>"),
  _tmpl$2 = _template$("<div  data-hydrate=\\"true\\">Hydration Content</div>");
const StreamingHydration = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(StreamingHydration, {
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and lazy loading 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-lazy></div>"),
  _tmpl$2 = _template$("Lazy Content"),
  _tmpl$3 = _template$("<div>Loading...</div>");
const StreamingLazy = ({
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  return _el;
})();
StreamingLazy._lazy = true;
const element = _createComponent$(Suspense, {
  get fallback() {
    return (() => {
      const _el3 = _tmpl$3();
      return _el3;
    })();
  },
  "children": [_createComponent$(StreamingLazy, {
    "children": [(() => {
      const _el2 = _tmpl$2();
      return _el2;
    })()]
  })]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and loading states 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-loading></div>"),
  _tmpl$2 = _template$("<div>Loading...</div>"),
  _tmpl$3 = _template$("<div>Loaded Content</div>");
const StreamingLoading = ({
  isLoading,
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => isLoading ? (() => {
    const _el2 = _tmpl$2();
    return _el2;
  })() : children);
  return _el;
})();
const element = _createComponent$(StreamingLoading, {
  "isLoading": false,
  "children": [(() => {
    const _el3 = _tmpl$3();
    return _el3;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and memo 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-memo></div>");
const StreamingMemo = ({
  value
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => value);
  return _el;
})();
StreamingMemo._memo = true;
const element = _createComponent$(StreamingMemo, {
  "value": "Memo Content"
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and multiple contexts 1`] = `
"import { createComponent as _createComponent$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-contexts></div>"),
  _tmpl$2 = _template$("<div>Multiple Contexts Content</div>");
const StreamingContexts = ({
  theme,
  user,
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => _createComponent$(ThemeContext.Provider, {
    get value() {
      return theme;
    },
    "children": [_createComponent$(UserContext.Provider, {
      get value() {
        return user;
      },
      "children": [children]
    })]
  }));
  _insert$(_nodes[0], () => _createComponent$(UserContext.Provider, {
    get value() {
      return user;
    },
    "children": [children]
  }));
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(StreamingContexts, {
  "theme": "dark",
  "user": {
    name: 'John'
  },
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and portals 1`] = `
"import { patchAttr as _patchAttr$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, memoEffect as _memoEffect$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-portal></div>"),
  _tmpl$2 = _template$("<div>Streaming Portal Content</div>");
const StreamingPortal = ({
  target,
  children
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  _memoEffect$(_p$ => {
    var _v$0 = target;
    _v$0 !== _p$.d0 && _patchAttr$(_nodes[0], "data-target", _p$.d0, _p$.d0 = _v$0);
    return _p$;
  }, {
    d0: undefined
  });
  return _el;
})();
const element = _createComponent$(StreamingPortal, {
  "target": "modal",
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and refs 1`] = `
"import { patchAttr as _patchAttr$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, memoEffect as _memoEffect$, createComponent as _createComponent$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-ref></div>"),
  _tmpl$2 = _template$("<div>Streaming Ref Content</div>");
const StreamingRef = ({
  children
}, ref) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => children);
  _memoEffect$(_p$ => {
    var _v$0 = ref;
    _v$0 !== _p$.r0 && _patchAttr$(_nodes[0], "ref", _p$.r0, _p$.r0 = _v$0);
    return _p$;
  }, {
    r0: undefined
  });
  return _el;
})();
const element = _createComponent$(StreamingRef, {
  get ref() {
    return React.createRef();
  },
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and suspense 1`] = `
"import { createComponent as _createComponent$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming></div>"),
  _tmpl$2 = _template$("<div>Streaming Content</div>"),
  _tmpl$3 = _template$("<div>Loading...</div>");
const StreamingSuspense = ({
  children,
  fallback
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => _createComponent$(Suspense, {
    get fallback() {
      return fallback;
    },
    "children": [children]
  }));
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(StreamingSuspense, {
  get fallback() {
    return (() => {
      const _el3 = _tmpl$3();
      return _el3;
    })();
  },
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > should work with streaming SSR and suspense boundaries 1`] = `
"import { createComponent as _createComponent$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div  data-streaming-suspense></div>"),
  _tmpl$2 = _template$("<div>Suspense Content</div>"),
  _tmpl$3 = _template$("<div>Loading...</div>");
const StreamingSuspenseBoundary = ({
  children,
  fallback
}) => (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => _createComponent$(Suspense, {
    get fallback() {
      return fallback;
    },
    "children": [children]
  }));
  _insert$(_nodes[0], () => children);
  return _el;
})();
const element = _createComponent$(StreamingSuspenseBoundary, {
  get fallback() {
    return (() => {
      const _el3 = _tmpl$3();
      return _el3;
    })();
  },
  "children": [(() => {
    const _el2 = _tmpl$2();
    return _el2;
  })()]
});"
`;

exports[`jsx SSR transform > transforms JSX element with JSX fragment 1`] = `
"const element = (() => {
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with JSX fragment as children 1`] = `
"import { getElement as _template$ } from "essor";
const _tmpl$ = _template$("<div></div>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with SVG tags 1`] = `
"import { getElement as _template$ } from "essor";
const _tmpl$ = _template$("<svg><circle  cx=\\"50\\" cy=\\"50\\" r=\\"40\\" stroke=\\"black\\" stroke-width=\\"3\\" fill=\\"red\\"></circle></svg>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with attributes 1`] = `
"import { getElement as _template$ } from "essor";
const _tmpl$ = _template$("<div  id=\\"myId\\" class=\\"myClass\\">Hello, World!</div>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with boolean attribute 1`] = `
"import { getElement as _template$ } from "essor";
const _tmpl$ = _template$("<input  disabled/>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with children 1`] = `
"import { getElement as _template$ } from "essor";
const _tmpl$ = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p></div>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with class and style attributes 1`] = `
"import { patchClass as _patchClass$, patchStyle as _patchStyle$, getElement as _template$, mapSSRNodes as _mapNodes$, memoEffect as _memoEffect$ } from "essor";
const _tmpl$ = _template$("<div>Hello, World!</div>");
const hasClass = true;
const style = {
  color: 'red',
  fontSize: '16px'
};
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _memoEffect$(_p$ => {
    var _v$0 = hasClass ? 'myClass' : '',
      _v$1 = style;
    _v$0 !== _p$.c0 && _patchClass$(_nodes[0], _p$.c0, _p$.c0 = _v$0);
    _v$1 !== _p$.s1 && _patchStyle$(_nodes[0], _p$.s1, _p$.s1 = _v$1);
    return _p$;
  }, {
    c0: undefined,
    s1: undefined
  });
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with conditional attributes 1`] = `
"import { patchClass as _patchClass$, getElement as _template$, mapSSRNodes as _mapNodes$, memoEffect as _memoEffect$ } from "essor";
const _tmpl$ = _template$("<div>Hello, World!</div>");
const hasClass = true;
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _memoEffect$(_p$ => {
    var _v$0 = hasClass ? 'myClass' : 'otherClass';
    _v$0 !== _p$.c0 && _patchClass$(_nodes[0], _p$.c0, _p$.c0 = _v$0);
    return _p$;
  }, {
    c0: undefined
  });
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with dynamic expressions 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div>Hello,<!>!</div>");
const name = 'John';
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 3]);
  _insert$(_nodes[0], () => name, _nodes[1]);
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with function components 1`] = `
"import { createComponent as _createComponent$, getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div></div>");
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _insert$(_nodes[0], () => _createComponent$(MyComponent, {
    "text": "Component 1"
  }));
  _insert$(_nodes[0], () => _createComponent$(MyComponent, {
    "text": "Component 2"
  }));
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with nested expressions and children 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$, patchAttr as _patchAttr$, memoEffect as _memoEffect$ } from "essor";
const _tmpl$ = _template$("<div><p>'s Profile</p><ul></ul></div>"),
  _tmpl$2 = _template$("<li>Item</li>");
const name = 'John';
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [2, 3, 4]);
  _insert$(_nodes[0], () => name, _nodes[1]);
  _insert$(_nodes[2], () => Array.from({
    length: 3
  }, (_, i) => (() => {
    const _el2 = _tmpl$2();
    const _nodes2 = _mapNodes$(_el2, [1]);
    _insert$(_nodes2[0], () => i + 1);
    _memoEffect$(_p$ => {
      var _v$0 = i;
      _v$0 !== _p$.k0 && _patchAttr$(_nodes2[0], "key", _p$.k0, _p$.k0 = _v$0);
      return _p$;
    }, {
      k0: undefined
    });
    return _el2;
  })()));
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with null and undefined attributes 1`] = `
"import { patchClass as _patchClass$, getElement as _template$, mapSSRNodes as _mapNodes$, patchAttr as _patchAttr$, memoEffect as _memoEffect$ } from "essor";
const _tmpl$ = _template$("<div>Hello, World!</div>");
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _patchAttr$(_nodes[0], "id", null);
  _memoEffect$(_p$ => {
    var _v$0 = undefined;
    _v$0 !== _p$.c0 && _patchClass$(_nodes[0], _p$.c0, _p$.c0 = _v$0);
    return _p$;
  }, {
    c0: undefined
  });
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with null and undefined children 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div><p>Paragraph 1</p><p>Paragraph 2</p></div>");
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 2, 4]);
  _insert$(_nodes[0], () => null, _nodes[1]);
  _insert$(_nodes[0], () => undefined, _nodes[2]);
  _insert$(_nodes[0], () => false, _nodes[2]);
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with null and undefined in expressions 1`] = `
"import { getElement as _template$, mapSSRNodes as _mapNodes$, insert as _insert$ } from "essor";
const _tmpl$ = _template$("<div><p>'s Profile</p><p>Paragraph 2</p></div>");
const name = null;
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1, 2, 3, 4]);
  _insert$(_nodes[1], () => name, _nodes[2]);
  _insert$(_nodes[0], () => undefined, _nodes[3]);
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with self-closing tags 1`] = `
"import { getElement as _template$ } from "essor";
const _tmpl$ = _template$("<div><img  src=\\"image.jpg\\" alt=\\"Image 1\\"/><img  src=\\"image.jpg\\" alt=\\"Image 2\\"/></div>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with spread attributes 1`] = `
"import { patchAttr as _patchAttr$, getElement as _template$, mapSSRNodes as _mapNodes$, memoEffect as _memoEffect$ } from "essor";
const _tmpl$ = _template$("<div>Hello, World!</div>");
const props = {
  id: 'myId',
  class: 'myClass'
};
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _memoEffect$(_p$ => {
    var _v$0 = props;
    _v$0 !== _p$._0 && _patchAttr$(_nodes[0], "_$spread$", _p$._0, _p$._0 = _v$0);
    return _p$;
  }, {
    _0: undefined
  });
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms JSX element with style attribute 1`] = `
"import { patchStyle as _patchStyle$, getElement as _template$, mapSSRNodes as _mapNodes$, memoEffect as _memoEffect$ } from "essor";
const _tmpl$ = _template$("<div>Hello, World!</div>");
const style = {
  color: 'red',
  fontSize: '16px'
};
const element = (() => {
  const _el = _tmpl$();
  const _nodes = _mapNodes$(_el, [1]);
  _memoEffect$(_p$ => {
    var _v$0 = style;
    _v$0 !== _p$.s0 && _patchStyle$(_nodes[0], _p$.s0, _p$.s0 = _v$0);
    return _p$;
  }, {
    s0: undefined
  });
  return _el;
})();"
`;

exports[`jsx SSR transform > transforms simple JSX element 1`] = `
"import { getElement as _template$ } from "essor";
const _tmpl$ = _template$("<div>Hello, World!</div>");
const element = (() => {
  const _el = _tmpl$();
  return _el;
})();"
`;
