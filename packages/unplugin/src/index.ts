import { createUnplugin } from 'unplugin';
import * as babel from '@babel/core';
import essorBabelPlugin from 'babel-plugin-essor';
import { createFilter } from 'vite';
import hmrRuntimeCode from './hmr-runtime.js?raw';
import type { UnpluginContextMeta, UnpluginFactory } from 'unplugin';
import type { Options } from './types';

/**
 * Virtual module ID for HMR runtime
 * Injected as an import in transformed files that have HMR components
 */
const VIRTUAL_MODULE_ID = 'virtual:essor-hmr';
const RESOLVED_VIRTUAL_MODULE_ID = '\0virtual:essor-hmr';

/**
 * Default plugin options
 */
const DEFAULT_OPTIONS = {
  symbol: '$',
  mode: 'client',
  props: true,
  hmr: true,
  enableFor: false,
};

/**
 * Performance: Pre-compiled regex and constants
 */
const FILE_EXTENSION_REGEX = /\.[cm]?[jt]sx?$/i;
const SKIP_DIRECTORIES = ['node_modules', 'dist', 'public'];

type BundlerType = 'vite' | 'webpack5' | 'rspack' | 'rollup' | 'esbuild' | 'standard';

/**
 * Detect bundler type from unplugin meta or environment variables
 *
 * This is important for HMR because different bundlers have different
 * HMR APIs (import.meta.hot.accept, module.hot.accept, etc.)
 */
function detectBundler(meta: UnpluginContextMeta): BundlerType {
  // First, try to detect from unplugin meta
  if (meta?.framework) {
    switch (meta.framework) {
      case 'vite':
        return 'vite';
      case 'webpack':
        return 'webpack5';
      case 'rspack':
        return 'rspack';
      case 'rollup':
        return 'rollup';
      case 'esbuild':
        return 'esbuild';
    }
  }

  // Fallback: detect from environment variables
  if (typeof process !== 'undefined' && process.env) {
    if (process.env.VITE || process.env.VITEST) return 'vite';
    if (process.env.WEBPACK_VERSION) return 'webpack5';
    if (process.env.RSPACK) return 'rspack';
  }

  // Default to standard if detection fails
  return 'standard';
}

/**
 * Generate HMR boilerplate code for a specific bundler
 *
 * @param bundlerType - The bundler type detected
 * @returns Object with imports and registration code
 */
function generateHMRCode(bundlerType: BundlerType) {
  // Import HMR utilities from virtual module
  const imports = [
    `import { createHMRComponent as __$createHMRComponent$__ } from "${VIRTUAL_MODULE_ID}";`,
    `import { hmrAccept as __$hmrAccept$__ } from "${VIRTUAL_MODULE_ID}";`,
  ];

  // Generate HMR acceptance code
  // The registry array (__$registry$__) is generated by the babel plugin
  const register = [
    'if (import.meta.hot) {',
    `  __$hmrAccept$__("${bundlerType}", import.meta.hot, __$registry$__);`,
    '  import.meta.hot?.accept()',
    '}',
  ].join('\n');

  return {
    importsCreateHMRComponent: `${imports[0]}\n`,
    importHmrAccept: `${imports[1]}\n`,
    register,
  };
}

export const unpluginFactory: UnpluginFactory<Options | undefined> = (
  options: Options = {},
  meta,
) => {
  // Create file filter based on include/exclude patterns
  const filter = createFilter(options.include, options.exclude);

  // Detect bundler type for HMR
  const bundlerType = detectBundler(meta);

  // Merge user options with defaults
  const finalOptions = {
    ...DEFAULT_OPTIONS,
    ...options,
    bundler: bundlerType, // Pass bundler type to babel plugin
  };

  return {
    name: 'unplugin-essor',

    /**
     * Vite-specific config to preserve JSX
     */
    config() {
      return {
        esbuild: {
          jsx: 'preserve',
        },
      };
    },

    /**
     * Resolve virtual HMR runtime module
     */
    resolveId(id: string) {
      if (id === VIRTUAL_MODULE_ID) {
        return RESOLVED_VIRTUAL_MODULE_ID;
      }
      return null;
    },

    /**
     * Load virtual HMR runtime module
     */
    load(id: string) {
      if (id === RESOLVED_VIRTUAL_MODULE_ID) {
        return {
          code: hmrRuntimeCode,
          map: null,
        };
      }
      return null;
    },

    /**
     * Transform code with Babel plugin
     */
    transform(code, id) {
      // Skip node_modules, dist, and public directories
      if (SKIP_DIRECTORIES.some(p => id.includes(p))) {
        return;
      }

      // Only transform JS/TS files
      if (!filter(id) || !FILE_EXTENSION_REGEX.test(id)) {
        return null;
      }

      const babelOptions = { ...finalOptions };

      // Transform with Babel (with error handling)
      let result;
      try {
        result = babel.transformSync(code, {
          filename: id,
          sourceMaps: true,
          sourceType: 'module',
          plugins: [[essorBabelPlugin, babelOptions]],
        });
      } catch (error) {
        console.error(`[unplugin-essor] Transform failed for ${id}:`, error);
        return null;
      }

      if (!result?.code) {
        return code;
      }

      // Determine if HMR should be enabled
      // HMR is only for client-side code with components
      const hmrEnabled =
        babelOptions.hmr && (babelOptions.mode === 'client' || babelOptions.mode === 'ssr');

      let finalCode = '';

      // Inject HMR code if enabled and components are present
      if (hmrEnabled) {
        const hmrCode = generateHMRCode(bundlerType);

        if (result.code.includes('__$createHMRComponent$__')) {
          finalCode = `${hmrCode.importsCreateHMRComponent}\n${finalCode}`;
        }
        finalCode += result.code;
        if (result.code.includes('__$registry$__')) {
          finalCode = `${hmrCode.importHmrAccept}\n${finalCode}\n${hmrCode.register}`;
        }
      } else {
        finalCode += result.code;
      }

      return {
        code: finalCode,
        map: result.map,
      };
    },
  };
};

export const unplugin = /* #__PURE__ */ createUnplugin(unpluginFactory);

export default unplugin;
