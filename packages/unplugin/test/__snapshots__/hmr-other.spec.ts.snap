// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`hMR - Rollup Platform > should work with rollup 1`] = `
"import { createComponent, signal, effect, template, createApp, mapNodes, insert } from 'essor';

/**
 * Essor HMR Runtime - Signal-based Hot Module Replacement
 *
 * This runtime enables precise component-level HMR updates without full page reloads:
 *
 * 1. **Signal Wrapping**: Each component is wrapped in a reactive signal
 * 2. **Signature Tracking**: Components are tracked by code signatures (from babel plugin)
 * 3. **Precise Updates**: Only components with changed signatures are updated
 * 4. **Effect Subscription**: Component instances subscribe to signal changes via effects
 * 5. **Bundler Agnostic**: Works with Vite, Webpack, Rspack, and other bundlers
 */

/**
 * Global component registry for HMR tracking
 *
 * Maps hmrId -> ComponentInfo where:
 * - hmrId: Unique identifier for component (fileHash:componentName)
 * - componentSignal: Reactive signal holding the current component function
 * - signature: Hash of component code (changes when code changes)
 * - instances: Set of active component instances
 * - cleanups: Map of cleanup functions for each instance's effect
 */
const componentRegistry = new Map();

/**
 * Utility function to handle invalidate or reload
 * @param hot - Hot module API object
 */
function invalidateOrReload(hot) {
  if (typeof hot?.invalidate === 'function') {
    hot.invalidate();
  } else if (typeof location !== 'undefined') {
    location.reload();
  }
}

/**
 * Create HMR-enabled component wrapper
 *
 * This function wraps a component to enable HMR:
 * 1. Creates or retrieves component registry entry
 * 2. Wraps component function to always read from latest signal value
 * 3. Sets up reactive effect to auto-update component when signal changes
 * 4. Returns regular component instance that auto-updates on HMR
 *
 * @param componentFn - Component function with __hmrId and __signature
 * @param props - Component props
 * @returns Component instance that responds to HMR updates
 */
function createHMRComponent(componentFn, props) {
  const { __hmrId: hmrId, __signature: signature } = componentFn;

  if (!hmrId) {
    // If no hmrId, create normal component
    return createComponent(componentFn, props);
  }

  let info = componentRegistry.get(hmrId);

  if (!info) {
    // First registration: create signal wrapped component
    info = {
      componentSignal: signal(componentFn),
      signature,
      instances: new Set(), // Track all instances
      cleanups: new Map(), // Store cleanup for each instance
    };
    componentRegistry.set(hmrId, info);
  }

  // Create Component instance
  const component = createComponent(componentFn, props);
  // Track this instance
  info.instances.add(component);

  // Create effect for this Component instance
  // The effect subscribes to componentSignal and updates the component
  // We read the signal value immediately to establish the dependency,
  // but only trigger updates on subsequent changes
  let initialized = false;
  const cleanup = effect(() => {
    // Read signal value to establish dependency
    const currentComponentFn = info.componentSignal.value;
    // Skip the initialization run - only update on actual changes
    if (!initialized) {
      initialized = true;
      return;
    }

    // Update this specific instance when signal changes
    try {
      component.component = currentComponentFn;
      component.forceUpdate();
    } catch (error) {
      console.error(\`[Essor HMR] Failed to update component instance:\`, error);
    }
  });

  // Store cleanup function for this instance
  info.cleanups.set(component, cleanup);

  // Integrate with component lifecycle - cleanup when component is destroyed
  // Store the original onBeforeUnmount handler if it exists
  const originalOnBeforeUnmount = component.onBeforeUnmount;
  component.onBeforeUnmount = function () {
    // Call original handler first
    if (originalOnBeforeUnmount) {
      originalOnBeforeUnmount.call(this);
    }
    // Cleanup HMR effect
    const cleanupFn = info.cleanups.get(component);
    if (cleanupFn) {
      cleanupFn();
      info.cleanups.delete(component);
    }
    // Remove from instances tracking
    info.instances.delete(component);
  };

  return component;
}

/**
 * Determine if a component needs to be updated
 *
 * A component should update if:
 * 1. Function instance changed (indicates module was re-executed)
 * 2. Signature changed (indicates component code was modified)
 *
 * @param oldInfo - Existing component registry info
 * @param newComponentFn - New component function from updated module
 * @param newSignature - New signature hash from updated module
 * @returns true if component should update
 */
function shouldUpdate(oldInfo, newComponentFn, newSignature) {
  if (!oldInfo) return true;

  // Check function instance (handles constant updates via module re-execution)
  const oldFn = oldInfo.componentSignal.value;
  if (oldFn !== newComponentFn) {
    return true;
  }

  // Check compile-time signature (handles component code changes)
  return oldInfo.signature !== newSignature;
}

/**
 * Check if a value is an HMR-enabled component
 *
 * @param value - Value to check
 * @returns true if value is a function with __hmrId property
 */
function isHMRComponent(value) {
  return value && typeof value === 'function' && value.__hmrId;
}

/**
 * Apply HMR updates to components
 *
 * Iterates through the new component registry and updates signals
 * for components whose signatures have changed. This triggers
 * reactive effects in component instances, causing them to re-render.
 *
 * @param registry - Array of components from updated module
 * @returns true if reload needed (errors occurred), false otherwise
 */
function applyUpdate(registry) {
  if (!Array.isArray(registry) || registry.length === 0) {
    return false;
  }

  let needsReload = false;

  for (const entry of registry) {
    const { __hmrId: hmrId, __signature: signature } = entry;
    const id = hmrId;
    const info = componentRegistry.get(hmrId);

    if (!info) {
      // New component, skip (will be registered on first render)
      continue;
    }

    // Use shouldUpdate to determine if update is needed
    if (!shouldUpdate(info, entry, signature)) {
      continue;
    }

    // Component changed, apply update
    try {
      info.signature = signature;
      info.componentSignal.value = entry;
    } catch (error) {
      console.error(\`[Essor HMR] Failed to update \${id}:\`, error);
      needsReload = true;
    }
  }

  return needsReload;
}

/**
 * Common handler for HMR updates across bundlers
 * @param hot - Hot module API
 * @param newModule - Updated module
 * @returns true if handled successfully
 */
function handleHMRUpdate(hot, newModule) {
  if (!newModule) {
    invalidateOrReload(hot);
    return false;
  }

  // Extract HMR components from new module
  const newRegistry = extractHMRComponents(newModule);
  if (newRegistry.length === 0) {
    return true;
  }

  const needsReload = applyUpdate(newRegistry);
  if (needsReload) {
    invalidateOrReload(hot);
  }
  return true;
}

/**
 * Setup HMR for Vite bundler
 *
 * Vite provides import.meta.hot.accept() callback that receives the new module
 */
function setupViteHMR(hot) {
  hot.accept(newModule => handleHMRUpdate(hot, newModule));
}

/**
 * Setup HMR for Webpack/Rspack bundlers
 *
 * Webpack-style HMR uses module.hot.accept() and hot.data for state persistence
 */
function setupWebpackHMR(hot, registry) {
  if (typeof hot.accept === 'function') {
    hot.accept();
  }

  // Apply update if previous data exists from last hot reload
  if (hot.data?.__$registry$__) {
    const needsReload = applyUpdate(registry);
    if (needsReload) {
      invalidateOrReload(hot);
    }
  }

  // Save current registry for next update
  if (typeof hot.dispose === 'function') {
    hot.dispose(data => {
      data.__$registry$__ = registry;
    });
  }
}

/**
 * Setup HMR for other bundlers (fallback)
 *
 * Attempts to work with any bundler that provides a basic hot module API
 */
function setupStandardHMR(hot, registry) {
  // Try accept callback mode first (more efficient)
  if (typeof hot.accept === 'function') {
    try {
      hot.accept(newModule => handleHMRUpdate(hot, newModule));
    } catch {
      // Some bundlers don't support accept with callback
      // Fall back to simple accept (for Webpack-style pattern)
      try {
        hot.accept();
      } catch (error_) {
        console.warn('[Essor HMR] Failed to setup hot.accept:', error_);
      }
    }
  }

  // Setup dispose handler for state persistence
  if (typeof hot.dispose === 'function') {
    hot.dispose(data => {
      data.__$registry$__ = registry;
      data.__essor_timestamp__ = Date.now();
    });
  }

  // Apply update if previous data exists (for Webpack-style HMR)
  if (hot.data?.__$registry$__) {
    const needsReload = applyUpdate(registry);
    if (needsReload) {
      invalidateOrReload(hot);
    }
  }
}

/**
 * Extract HMR components from a module
 *
 * Looks for __$registry$__ array first (generated by babel plugin),
 * then falls back to scanning all exports for HMR components
 *
 * @param module - Module object to scan
 * @returns Array of HMR component functions
 */
function extractHMRComponents(module) {
  if (!module) return [];

  // Prefer __$registry$__
  if (Array.isArray(module.__$registry$__)) {
    return module.__$registry$__;
  }

  // Otherwise search in exports
  const components = [];
  for (const key of Object.keys(module)) {
    const value = module[key];
    if (isHMRComponent(value)) {
      components.push(value);
    }
  }
  return components;
}

/**
 * Main HMR entry point
 *
 * Called from transformed modules to set up HMR based on bundler type
 *
 * @param bundlerType - Type of bundler (vite, webpack5, rspack, etc.)
 * @param hot - Hot module API object (import.meta.hot or module.hot)
 * @param registry - Array of components from current module
 * @returns true if HMR setup succeeded, false otherwise
 */
function hmrAccept(bundlerType, hot, registry) {
  if (!hot || !registry || registry.length === 0) {
    return false;
  }

  switch (bundlerType) {
    case 'vite':
      setupViteHMR(hot);
      break;
    case 'webpack':
    case 'rspack':
      setupWebpackHMR(hot, registry);
      break;
    default:
      // Use standard HMR setup
      setupStandardHMR(hot, registry);
      break;
  }

  return true;
}

const _$tmpl = template("<div>Foo</div>"), _$tmpl2 = template("<div>Bar</div>"), _$tmpl3 = template("<div></div>");
function Foo() {
  return (() => {
    const _$el = _$tmpl();
    return _$el;
  })();
}
Foo.__signature = "174rcvv";
Foo.__hmrId = "35tyqe:Foo";
function Bar() {
  return (() => {
    const _$el2 = _$tmpl2();
    return _$el2;
  })();
}
Bar.__signature = "k90znw";
Bar.__hmrId = "35tyqe:Bar";
function App() {
  return (() => {
    const _$el3 = _$tmpl3();
    const _$nodes3 = mapNodes(_$el3, [1]);
    insert(_$nodes3[0], createHMRComponent(Foo, {}));
    insert(_$nodes3[0], createHMRComponent(Bar, {}));
    return _$el3;
  })();
}
App.__signature = "1i25p8q";
App.__hmrId = "35tyqe:App";
createApp(createHMRComponent(App), "#root");
const __$registry$__ = [Foo, Bar, App];
if (import.meta.hot) {
  hmrAccept("rollup", import.meta.hot, __$registry$__);
  import.meta.hot?.accept();
}
"
`;

exports[`hMR - Rollup Platform > should work with rollup 2`] = `
"import { createComponent, signal, effect, template, createApp, mapNodes, insert } from 'essor';

/**
 * Essor HMR Runtime - Signal-based Hot Module Replacement
 *
 * This runtime enables precise component-level HMR updates without full page reloads:
 *
 * 1. **Signal Wrapping**: Each component is wrapped in a reactive signal
 * 2. **Signature Tracking**: Components are tracked by code signatures (from babel plugin)
 * 3. **Precise Updates**: Only components with changed signatures are updated
 * 4. **Effect Subscription**: Component instances subscribe to signal changes via effects
 * 5. **Bundler Agnostic**: Works with Vite, Webpack, Rspack, and other bundlers
 */

/**
 * Global component registry for HMR tracking
 *
 * Maps hmrId -> ComponentInfo where:
 * - hmrId: Unique identifier for component (fileHash:componentName)
 * - componentSignal: Reactive signal holding the current component function
 * - signature: Hash of component code (changes when code changes)
 * - instances: Set of active component instances
 * - cleanups: Map of cleanup functions for each instance's effect
 */
const componentRegistry = new Map();

/**
 * Utility function to handle invalidate or reload
 * @param hot - Hot module API object
 */
function invalidateOrReload(hot) {
  if (typeof hot?.invalidate === 'function') {
    hot.invalidate();
  } else if (typeof location !== 'undefined') {
    location.reload();
  }
}

/**
 * Create HMR-enabled component wrapper
 *
 * This function wraps a component to enable HMR:
 * 1. Creates or retrieves component registry entry
 * 2. Wraps component function to always read from latest signal value
 * 3. Sets up reactive effect to auto-update component when signal changes
 * 4. Returns regular component instance that auto-updates on HMR
 *
 * @param componentFn - Component function with __hmrId and __signature
 * @param props - Component props
 * @returns Component instance that responds to HMR updates
 */
function createHMRComponent(componentFn, props) {
  const { __hmrId: hmrId, __signature: signature } = componentFn;

  if (!hmrId) {
    // If no hmrId, create normal component
    return createComponent(componentFn, props);
  }

  let info = componentRegistry.get(hmrId);

  if (!info) {
    // First registration: create signal wrapped component
    info = {
      componentSignal: signal(componentFn),
      signature,
      instances: new Set(), // Track all instances
      cleanups: new Map(), // Store cleanup for each instance
    };
    componentRegistry.set(hmrId, info);
  }

  // Create Component instance
  const component = createComponent(componentFn, props);
  // Track this instance
  info.instances.add(component);

  // Create effect for this Component instance
  // The effect subscribes to componentSignal and updates the component
  // We read the signal value immediately to establish the dependency,
  // but only trigger updates on subsequent changes
  let initialized = false;
  const cleanup = effect(() => {
    // Read signal value to establish dependency
    const currentComponentFn = info.componentSignal.value;
    // Skip the initialization run - only update on actual changes
    if (!initialized) {
      initialized = true;
      return;
    }

    // Update this specific instance when signal changes
    try {
      component.component = currentComponentFn;
      component.forceUpdate();
    } catch (error) {
      console.error(\`[Essor HMR] Failed to update component instance:\`, error);
    }
  });

  // Store cleanup function for this instance
  info.cleanups.set(component, cleanup);

  // Integrate with component lifecycle - cleanup when component is destroyed
  // Store the original onBeforeUnmount handler if it exists
  const originalOnBeforeUnmount = component.onBeforeUnmount;
  component.onBeforeUnmount = function () {
    // Call original handler first
    if (originalOnBeforeUnmount) {
      originalOnBeforeUnmount.call(this);
    }
    // Cleanup HMR effect
    const cleanupFn = info.cleanups.get(component);
    if (cleanupFn) {
      cleanupFn();
      info.cleanups.delete(component);
    }
    // Remove from instances tracking
    info.instances.delete(component);
  };

  return component;
}

/**
 * Determine if a component needs to be updated
 *
 * A component should update if:
 * 1. Function instance changed (indicates module was re-executed)
 * 2. Signature changed (indicates component code was modified)
 *
 * @param oldInfo - Existing component registry info
 * @param newComponentFn - New component function from updated module
 * @param newSignature - New signature hash from updated module
 * @returns true if component should update
 */
function shouldUpdate(oldInfo, newComponentFn, newSignature) {
  if (!oldInfo) return true;

  // Check function instance (handles constant updates via module re-execution)
  const oldFn = oldInfo.componentSignal.value;
  if (oldFn !== newComponentFn) {
    return true;
  }

  // Check compile-time signature (handles component code changes)
  return oldInfo.signature !== newSignature;
}

/**
 * Check if a value is an HMR-enabled component
 *
 * @param value - Value to check
 * @returns true if value is a function with __hmrId property
 */
function isHMRComponent(value) {
  return value && typeof value === 'function' && value.__hmrId;
}

/**
 * Apply HMR updates to components
 *
 * Iterates through the new component registry and updates signals
 * for components whose signatures have changed. This triggers
 * reactive effects in component instances, causing them to re-render.
 *
 * @param registry - Array of components from updated module
 * @returns true if reload needed (errors occurred), false otherwise
 */
function applyUpdate(registry) {
  if (!Array.isArray(registry) || registry.length === 0) {
    return false;
  }

  let needsReload = false;

  for (const entry of registry) {
    const { __hmrId: hmrId, __signature: signature } = entry;
    const id = hmrId;
    const info = componentRegistry.get(hmrId);

    if (!info) {
      // New component, skip (will be registered on first render)
      continue;
    }

    // Use shouldUpdate to determine if update is needed
    if (!shouldUpdate(info, entry, signature)) {
      continue;
    }

    // Component changed, apply update
    try {
      info.signature = signature;
      info.componentSignal.value = entry;
    } catch (error) {
      console.error(\`[Essor HMR] Failed to update \${id}:\`, error);
      needsReload = true;
    }
  }

  return needsReload;
}

/**
 * Common handler for HMR updates across bundlers
 * @param hot - Hot module API
 * @param newModule - Updated module
 * @returns true if handled successfully
 */
function handleHMRUpdate(hot, newModule) {
  if (!newModule) {
    invalidateOrReload(hot);
    return false;
  }

  // Extract HMR components from new module
  const newRegistry = extractHMRComponents(newModule);
  if (newRegistry.length === 0) {
    return true;
  }

  const needsReload = applyUpdate(newRegistry);
  if (needsReload) {
    invalidateOrReload(hot);
  }
  return true;
}

/**
 * Setup HMR for Vite bundler
 *
 * Vite provides import.meta.hot.accept() callback that receives the new module
 */
function setupViteHMR(hot) {
  hot.accept(newModule => handleHMRUpdate(hot, newModule));
}

/**
 * Setup HMR for Webpack/Rspack bundlers
 *
 * Webpack-style HMR uses module.hot.accept() and hot.data for state persistence
 */
function setupWebpackHMR(hot, registry) {
  if (typeof hot.accept === 'function') {
    hot.accept();
  }

  // Apply update if previous data exists from last hot reload
  if (hot.data?.__$registry$__) {
    const needsReload = applyUpdate(registry);
    if (needsReload) {
      invalidateOrReload(hot);
    }
  }

  // Save current registry for next update
  if (typeof hot.dispose === 'function') {
    hot.dispose(data => {
      data.__$registry$__ = registry;
    });
  }
}

/**
 * Setup HMR for other bundlers (fallback)
 *
 * Attempts to work with any bundler that provides a basic hot module API
 */
function setupStandardHMR(hot, registry) {
  // Try accept callback mode first (more efficient)
  if (typeof hot.accept === 'function') {
    try {
      hot.accept(newModule => handleHMRUpdate(hot, newModule));
    } catch {
      // Some bundlers don't support accept with callback
      // Fall back to simple accept (for Webpack-style pattern)
      try {
        hot.accept();
      } catch (error_) {
        console.warn('[Essor HMR] Failed to setup hot.accept:', error_);
      }
    }
  }

  // Setup dispose handler for state persistence
  if (typeof hot.dispose === 'function') {
    hot.dispose(data => {
      data.__$registry$__ = registry;
      data.__essor_timestamp__ = Date.now();
    });
  }

  // Apply update if previous data exists (for Webpack-style HMR)
  if (hot.data?.__$registry$__) {
    const needsReload = applyUpdate(registry);
    if (needsReload) {
      invalidateOrReload(hot);
    }
  }
}

/**
 * Extract HMR components from a module
 *
 * Looks for __$registry$__ array first (generated by babel plugin),
 * then falls back to scanning all exports for HMR components
 *
 * @param module - Module object to scan
 * @returns Array of HMR component functions
 */
function extractHMRComponents(module) {
  if (!module) return [];

  // Prefer __$registry$__
  if (Array.isArray(module.__$registry$__)) {
    return module.__$registry$__;
  }

  // Otherwise search in exports
  const components = [];
  for (const key of Object.keys(module)) {
    const value = module[key];
    if (isHMRComponent(value)) {
      components.push(value);
    }
  }
  return components;
}

/**
 * Main HMR entry point
 *
 * Called from transformed modules to set up HMR based on bundler type
 *
 * @param bundlerType - Type of bundler (vite, webpack5, rspack, etc.)
 * @param hot - Hot module API object (import.meta.hot or module.hot)
 * @param registry - Array of components from current module
 * @returns true if HMR setup succeeded, false otherwise
 */
function hmrAccept(bundlerType, hot, registry) {
  if (!hot || !registry || registry.length === 0) {
    return false;
  }

  switch (bundlerType) {
    case 'vite':
      setupViteHMR(hot);
      break;
    case 'webpack':
    case 'rspack':
      setupWebpackHMR(hot, registry);
      break;
    default:
      // Use standard HMR setup
      setupStandardHMR(hot, registry);
      break;
  }

  return true;
}

const _$tmpl = template("<div>A</div>"), _$tmpl2 = template("<div>B</div>"), _$tmpl3 = template("<div></div>");
function ComponentA() {
  return (() => {
    const _$el = _$tmpl();
    return _$el;
  })();
}
ComponentA.__signature = "szj98";
ComponentA.__hmrId = "35tyqe:ComponentA";
const ComponentB = () => (() => {
  const _$el2 = _$tmpl2();
  return _$el2;
})();
ComponentB.__signature = "1xhowjs";
ComponentB.__hmrId = "35tyqe:ComponentB";
function App() {
  return (() => {
    const _$el3 = _$tmpl3();
    const _$nodes3 = mapNodes(_$el3, [1]);
    insert(_$nodes3[0], createHMRComponent(ComponentA, {}));
    insert(_$nodes3[0], createHMRComponent(ComponentB, {}));
    return _$el3;
  })();
}
App.__signature = "1gy08hq";
App.__hmrId = "35tyqe:App";
createApp(createHMRComponent(App), "#root");
const __$registry$__ = [ComponentA, ComponentB, App];
if (import.meta.hot) {
  hmrAccept("rollup", import.meta.hot, __$registry$__);
  import.meta.hot?.accept();
}

export { ComponentA, ComponentB, App as default };
"
`;

exports[`hMR - Rollup Platform > should work with rollup 3`] = `
"import { createComponent, signal, effect, template, createApp, mapNodes, insert } from 'essor';

/**
 * Essor HMR Runtime - Signal-based Hot Module Replacement
 *
 * This runtime enables precise component-level HMR updates without full page reloads:
 *
 * 1. **Signal Wrapping**: Each component is wrapped in a reactive signal
 * 2. **Signature Tracking**: Components are tracked by code signatures (from babel plugin)
 * 3. **Precise Updates**: Only components with changed signatures are updated
 * 4. **Effect Subscription**: Component instances subscribe to signal changes via effects
 * 5. **Bundler Agnostic**: Works with Vite, Webpack, Rspack, and other bundlers
 */

/**
 * Global component registry for HMR tracking
 *
 * Maps hmrId -> ComponentInfo where:
 * - hmrId: Unique identifier for component (fileHash:componentName)
 * - componentSignal: Reactive signal holding the current component function
 * - signature: Hash of component code (changes when code changes)
 * - instances: Set of active component instances
 * - cleanups: Map of cleanup functions for each instance's effect
 */
const componentRegistry = new Map();

/**
 * Utility function to handle invalidate or reload
 * @param hot - Hot module API object
 */
function invalidateOrReload(hot) {
  if (typeof hot?.invalidate === 'function') {
    hot.invalidate();
  } else if (typeof location !== 'undefined') {
    location.reload();
  }
}

/**
 * Create HMR-enabled component wrapper
 *
 * This function wraps a component to enable HMR:
 * 1. Creates or retrieves component registry entry
 * 2. Wraps component function to always read from latest signal value
 * 3. Sets up reactive effect to auto-update component when signal changes
 * 4. Returns regular component instance that auto-updates on HMR
 *
 * @param componentFn - Component function with __hmrId and __signature
 * @param props - Component props
 * @returns Component instance that responds to HMR updates
 */
function createHMRComponent(componentFn, props) {
  const { __hmrId: hmrId, __signature: signature } = componentFn;

  if (!hmrId) {
    // If no hmrId, create normal component
    return createComponent(componentFn, props);
  }

  let info = componentRegistry.get(hmrId);

  if (!info) {
    // First registration: create signal wrapped component
    info = {
      componentSignal: signal(componentFn),
      signature,
      instances: new Set(), // Track all instances
      cleanups: new Map(), // Store cleanup for each instance
    };
    componentRegistry.set(hmrId, info);
  }

  // Create Component instance
  const component = createComponent(componentFn, props);
  // Track this instance
  info.instances.add(component);

  // Create effect for this Component instance
  // The effect subscribes to componentSignal and updates the component
  // We read the signal value immediately to establish the dependency,
  // but only trigger updates on subsequent changes
  let initialized = false;
  const cleanup = effect(() => {
    // Read signal value to establish dependency
    const currentComponentFn = info.componentSignal.value;
    // Skip the initialization run - only update on actual changes
    if (!initialized) {
      initialized = true;
      return;
    }

    // Update this specific instance when signal changes
    try {
      component.component = currentComponentFn;
      component.forceUpdate();
    } catch (error) {
      console.error(\`[Essor HMR] Failed to update component instance:\`, error);
    }
  });

  // Store cleanup function for this instance
  info.cleanups.set(component, cleanup);

  // Integrate with component lifecycle - cleanup when component is destroyed
  // Store the original onBeforeUnmount handler if it exists
  const originalOnBeforeUnmount = component.onBeforeUnmount;
  component.onBeforeUnmount = function () {
    // Call original handler first
    if (originalOnBeforeUnmount) {
      originalOnBeforeUnmount.call(this);
    }
    // Cleanup HMR effect
    const cleanupFn = info.cleanups.get(component);
    if (cleanupFn) {
      cleanupFn();
      info.cleanups.delete(component);
    }
    // Remove from instances tracking
    info.instances.delete(component);
  };

  return component;
}

/**
 * Determine if a component needs to be updated
 *
 * A component should update if:
 * 1. Function instance changed (indicates module was re-executed)
 * 2. Signature changed (indicates component code was modified)
 *
 * @param oldInfo - Existing component registry info
 * @param newComponentFn - New component function from updated module
 * @param newSignature - New signature hash from updated module
 * @returns true if component should update
 */
function shouldUpdate(oldInfo, newComponentFn, newSignature) {
  if (!oldInfo) return true;

  // Check function instance (handles constant updates via module re-execution)
  const oldFn = oldInfo.componentSignal.value;
  if (oldFn !== newComponentFn) {
    return true;
  }

  // Check compile-time signature (handles component code changes)
  return oldInfo.signature !== newSignature;
}

/**
 * Check if a value is an HMR-enabled component
 *
 * @param value - Value to check
 * @returns true if value is a function with __hmrId property
 */
function isHMRComponent(value) {
  return value && typeof value === 'function' && value.__hmrId;
}

/**
 * Apply HMR updates to components
 *
 * Iterates through the new component registry and updates signals
 * for components whose signatures have changed. This triggers
 * reactive effects in component instances, causing them to re-render.
 *
 * @param registry - Array of components from updated module
 * @returns true if reload needed (errors occurred), false otherwise
 */
function applyUpdate(registry) {
  if (!Array.isArray(registry) || registry.length === 0) {
    return false;
  }

  let needsReload = false;

  for (const entry of registry) {
    const { __hmrId: hmrId, __signature: signature } = entry;
    const id = hmrId;
    const info = componentRegistry.get(hmrId);

    if (!info) {
      // New component, skip (will be registered on first render)
      continue;
    }

    // Use shouldUpdate to determine if update is needed
    if (!shouldUpdate(info, entry, signature)) {
      continue;
    }

    // Component changed, apply update
    try {
      info.signature = signature;
      info.componentSignal.value = entry;
    } catch (error) {
      console.error(\`[Essor HMR] Failed to update \${id}:\`, error);
      needsReload = true;
    }
  }

  return needsReload;
}

/**
 * Common handler for HMR updates across bundlers
 * @param hot - Hot module API
 * @param newModule - Updated module
 * @returns true if handled successfully
 */
function handleHMRUpdate(hot, newModule) {
  if (!newModule) {
    invalidateOrReload(hot);
    return false;
  }

  // Extract HMR components from new module
  const newRegistry = extractHMRComponents(newModule);
  if (newRegistry.length === 0) {
    return true;
  }

  const needsReload = applyUpdate(newRegistry);
  if (needsReload) {
    invalidateOrReload(hot);
  }
  return true;
}

/**
 * Setup HMR for Vite bundler
 *
 * Vite provides import.meta.hot.accept() callback that receives the new module
 */
function setupViteHMR(hot) {
  hot.accept(newModule => handleHMRUpdate(hot, newModule));
}

/**
 * Setup HMR for Webpack/Rspack bundlers
 *
 * Webpack-style HMR uses module.hot.accept() and hot.data for state persistence
 */
function setupWebpackHMR(hot, registry) {
  if (typeof hot.accept === 'function') {
    hot.accept();
  }

  // Apply update if previous data exists from last hot reload
  if (hot.data?.__$registry$__) {
    const needsReload = applyUpdate(registry);
    if (needsReload) {
      invalidateOrReload(hot);
    }
  }

  // Save current registry for next update
  if (typeof hot.dispose === 'function') {
    hot.dispose(data => {
      data.__$registry$__ = registry;
    });
  }
}

/**
 * Setup HMR for other bundlers (fallback)
 *
 * Attempts to work with any bundler that provides a basic hot module API
 */
function setupStandardHMR(hot, registry) {
  // Try accept callback mode first (more efficient)
  if (typeof hot.accept === 'function') {
    try {
      hot.accept(newModule => handleHMRUpdate(hot, newModule));
    } catch {
      // Some bundlers don't support accept with callback
      // Fall back to simple accept (for Webpack-style pattern)
      try {
        hot.accept();
      } catch (error_) {
        console.warn('[Essor HMR] Failed to setup hot.accept:', error_);
      }
    }
  }

  // Setup dispose handler for state persistence
  if (typeof hot.dispose === 'function') {
    hot.dispose(data => {
      data.__$registry$__ = registry;
      data.__essor_timestamp__ = Date.now();
    });
  }

  // Apply update if previous data exists (for Webpack-style HMR)
  if (hot.data?.__$registry$__) {
    const needsReload = applyUpdate(registry);
    if (needsReload) {
      invalidateOrReload(hot);
    }
  }
}

/**
 * Extract HMR components from a module
 *
 * Looks for __$registry$__ array first (generated by babel plugin),
 * then falls back to scanning all exports for HMR components
 *
 * @param module - Module object to scan
 * @returns Array of HMR component functions
 */
function extractHMRComponents(module) {
  if (!module) return [];

  // Prefer __$registry$__
  if (Array.isArray(module.__$registry$__)) {
    return module.__$registry$__;
  }

  // Otherwise search in exports
  const components = [];
  for (const key of Object.keys(module)) {
    const value = module[key];
    if (isHMRComponent(value)) {
      components.push(value);
    }
  }
  return components;
}

/**
 * Main HMR entry point
 *
 * Called from transformed modules to set up HMR based on bundler type
 *
 * @param bundlerType - Type of bundler (vite, webpack5, rspack, etc.)
 * @param hot - Hot module API object (import.meta.hot or module.hot)
 * @param registry - Array of components from current module
 * @returns true if HMR setup succeeded, false otherwise
 */
function hmrAccept(bundlerType, hot, registry) {
  if (!hot || !registry || registry.length === 0) {
    return false;
  }

  switch (bundlerType) {
    case 'vite':
      setupViteHMR(hot);
      break;
    case 'webpack':
    case 'rspack':
      setupWebpackHMR(hot, registry);
      break;
    default:
      // Use standard HMR setup
      setupStandardHMR(hot, registry);
      break;
  }

  return true;
}

const _$tmpl = template("<div>Hello</div>");
function PropsComponent(props) {
  return (() => {
    const _$el = _$tmpl();
    const _$nodes = mapNodes(_$el, [1]);
    insert(_$nodes[0], () => props.name);
    return _$el;
  })();
}
PropsComponent.__signature = "eh956m";
PropsComponent.__hmrId = "35tyqe:PropsComponent";
createApp(createHMRComponent(() => createHMRComponent(PropsComponent, {
  "name": "World"
})), "#root");
const __$registry$__ = [PropsComponent];
if (import.meta.hot) {
  hmrAccept("rollup", import.meta.hot, __$registry$__);
  import.meta.hot?.accept();
}
"
`;

exports[`hMR - Rollup Platform > should work with rollup 4`] = `
"import { createComponent, signal, effect, template, createApp, delegateEvents, mapNodes, insert } from 'essor';

/**
 * Essor HMR Runtime - Signal-based Hot Module Replacement
 *
 * This runtime enables precise component-level HMR updates without full page reloads:
 *
 * 1. **Signal Wrapping**: Each component is wrapped in a reactive signal
 * 2. **Signature Tracking**: Components are tracked by code signatures (from babel plugin)
 * 3. **Precise Updates**: Only components with changed signatures are updated
 * 4. **Effect Subscription**: Component instances subscribe to signal changes via effects
 * 5. **Bundler Agnostic**: Works with Vite, Webpack, Rspack, and other bundlers
 */

/**
 * Global component registry for HMR tracking
 *
 * Maps hmrId -> ComponentInfo where:
 * - hmrId: Unique identifier for component (fileHash:componentName)
 * - componentSignal: Reactive signal holding the current component function
 * - signature: Hash of component code (changes when code changes)
 * - instances: Set of active component instances
 * - cleanups: Map of cleanup functions for each instance's effect
 */
const componentRegistry = new Map();

/**
 * Utility function to handle invalidate or reload
 * @param hot - Hot module API object
 */
function invalidateOrReload(hot) {
  if (typeof hot?.invalidate === 'function') {
    hot.invalidate();
  } else if (typeof location !== 'undefined') {
    location.reload();
  }
}

/**
 * Create HMR-enabled component wrapper
 *
 * This function wraps a component to enable HMR:
 * 1. Creates or retrieves component registry entry
 * 2. Wraps component function to always read from latest signal value
 * 3. Sets up reactive effect to auto-update component when signal changes
 * 4. Returns regular component instance that auto-updates on HMR
 *
 * @param componentFn - Component function with __hmrId and __signature
 * @param props - Component props
 * @returns Component instance that responds to HMR updates
 */
function createHMRComponent(componentFn, props) {
  const { __hmrId: hmrId, __signature: signature } = componentFn;

  if (!hmrId) {
    // If no hmrId, create normal component
    return createComponent(componentFn, props);
  }

  let info = componentRegistry.get(hmrId);

  if (!info) {
    // First registration: create signal wrapped component
    info = {
      componentSignal: signal(componentFn),
      signature,
      instances: new Set(), // Track all instances
      cleanups: new Map(), // Store cleanup for each instance
    };
    componentRegistry.set(hmrId, info);
  }

  // Create Component instance
  const component = createComponent(componentFn, props);
  // Track this instance
  info.instances.add(component);

  // Create effect for this Component instance
  // The effect subscribes to componentSignal and updates the component
  // We read the signal value immediately to establish the dependency,
  // but only trigger updates on subsequent changes
  let initialized = false;
  const cleanup = effect(() => {
    // Read signal value to establish dependency
    const currentComponentFn = info.componentSignal.value;
    // Skip the initialization run - only update on actual changes
    if (!initialized) {
      initialized = true;
      return;
    }

    // Update this specific instance when signal changes
    try {
      component.component = currentComponentFn;
      component.forceUpdate();
    } catch (error) {
      console.error(\`[Essor HMR] Failed to update component instance:\`, error);
    }
  });

  // Store cleanup function for this instance
  info.cleanups.set(component, cleanup);

  // Integrate with component lifecycle - cleanup when component is destroyed
  // Store the original onBeforeUnmount handler if it exists
  const originalOnBeforeUnmount = component.onBeforeUnmount;
  component.onBeforeUnmount = function () {
    // Call original handler first
    if (originalOnBeforeUnmount) {
      originalOnBeforeUnmount.call(this);
    }
    // Cleanup HMR effect
    const cleanupFn = info.cleanups.get(component);
    if (cleanupFn) {
      cleanupFn();
      info.cleanups.delete(component);
    }
    // Remove from instances tracking
    info.instances.delete(component);
  };

  return component;
}

/**
 * Determine if a component needs to be updated
 *
 * A component should update if:
 * 1. Function instance changed (indicates module was re-executed)
 * 2. Signature changed (indicates component code was modified)
 *
 * @param oldInfo - Existing component registry info
 * @param newComponentFn - New component function from updated module
 * @param newSignature - New signature hash from updated module
 * @returns true if component should update
 */
function shouldUpdate(oldInfo, newComponentFn, newSignature) {
  if (!oldInfo) return true;

  // Check function instance (handles constant updates via module re-execution)
  const oldFn = oldInfo.componentSignal.value;
  if (oldFn !== newComponentFn) {
    return true;
  }

  // Check compile-time signature (handles component code changes)
  return oldInfo.signature !== newSignature;
}

/**
 * Check if a value is an HMR-enabled component
 *
 * @param value - Value to check
 * @returns true if value is a function with __hmrId property
 */
function isHMRComponent(value) {
  return value && typeof value === 'function' && value.__hmrId;
}

/**
 * Apply HMR updates to components
 *
 * Iterates through the new component registry and updates signals
 * for components whose signatures have changed. This triggers
 * reactive effects in component instances, causing them to re-render.
 *
 * @param registry - Array of components from updated module
 * @returns true if reload needed (errors occurred), false otherwise
 */
function applyUpdate(registry) {
  if (!Array.isArray(registry) || registry.length === 0) {
    return false;
  }

  let needsReload = false;

  for (const entry of registry) {
    const { __hmrId: hmrId, __signature: signature } = entry;
    const id = hmrId;
    const info = componentRegistry.get(hmrId);

    if (!info) {
      // New component, skip (will be registered on first render)
      continue;
    }

    // Use shouldUpdate to determine if update is needed
    if (!shouldUpdate(info, entry, signature)) {
      continue;
    }

    // Component changed, apply update
    try {
      info.signature = signature;
      info.componentSignal.value = entry;
    } catch (error) {
      console.error(\`[Essor HMR] Failed to update \${id}:\`, error);
      needsReload = true;
    }
  }

  return needsReload;
}

/**
 * Common handler for HMR updates across bundlers
 * @param hot - Hot module API
 * @param newModule - Updated module
 * @returns true if handled successfully
 */
function handleHMRUpdate(hot, newModule) {
  if (!newModule) {
    invalidateOrReload(hot);
    return false;
  }

  // Extract HMR components from new module
  const newRegistry = extractHMRComponents(newModule);
  if (newRegistry.length === 0) {
    return true;
  }

  const needsReload = applyUpdate(newRegistry);
  if (needsReload) {
    invalidateOrReload(hot);
  }
  return true;
}

/**
 * Setup HMR for Vite bundler
 *
 * Vite provides import.meta.hot.accept() callback that receives the new module
 */
function setupViteHMR(hot) {
  hot.accept(newModule => handleHMRUpdate(hot, newModule));
}

/**
 * Setup HMR for Webpack/Rspack bundlers
 *
 * Webpack-style HMR uses module.hot.accept() and hot.data for state persistence
 */
function setupWebpackHMR(hot, registry) {
  if (typeof hot.accept === 'function') {
    hot.accept();
  }

  // Apply update if previous data exists from last hot reload
  if (hot.data?.__$registry$__) {
    const needsReload = applyUpdate(registry);
    if (needsReload) {
      invalidateOrReload(hot);
    }
  }

  // Save current registry for next update
  if (typeof hot.dispose === 'function') {
    hot.dispose(data => {
      data.__$registry$__ = registry;
    });
  }
}

/**
 * Setup HMR for other bundlers (fallback)
 *
 * Attempts to work with any bundler that provides a basic hot module API
 */
function setupStandardHMR(hot, registry) {
  // Try accept callback mode first (more efficient)
  if (typeof hot.accept === 'function') {
    try {
      hot.accept(newModule => handleHMRUpdate(hot, newModule));
    } catch {
      // Some bundlers don't support accept with callback
      // Fall back to simple accept (for Webpack-style pattern)
      try {
        hot.accept();
      } catch (error_) {
        console.warn('[Essor HMR] Failed to setup hot.accept:', error_);
      }
    }
  }

  // Setup dispose handler for state persistence
  if (typeof hot.dispose === 'function') {
    hot.dispose(data => {
      data.__$registry$__ = registry;
      data.__essor_timestamp__ = Date.now();
    });
  }

  // Apply update if previous data exists (for Webpack-style HMR)
  if (hot.data?.__$registry$__) {
    const needsReload = applyUpdate(registry);
    if (needsReload) {
      invalidateOrReload(hot);
    }
  }
}

/**
 * Extract HMR components from a module
 *
 * Looks for __$registry$__ array first (generated by babel plugin),
 * then falls back to scanning all exports for HMR components
 *
 * @param module - Module object to scan
 * @returns Array of HMR component functions
 */
function extractHMRComponents(module) {
  if (!module) return [];

  // Prefer __$registry$__
  if (Array.isArray(module.__$registry$__)) {
    return module.__$registry$__;
  }

  // Otherwise search in exports
  const components = [];
  for (const key of Object.keys(module)) {
    const value = module[key];
    if (isHMRComponent(value)) {
      components.push(value);
    }
  }
  return components;
}

/**
 * Main HMR entry point
 *
 * Called from transformed modules to set up HMR based on bundler type
 *
 * @param bundlerType - Type of bundler (vite, webpack5, rspack, etc.)
 * @param hot - Hot module API object (import.meta.hot or module.hot)
 * @param registry - Array of components from current module
 * @returns true if HMR setup succeeded, false otherwise
 */
function hmrAccept(bundlerType, hot, registry) {
  if (!hot || !registry || registry.length === 0) {
    return false;
  }

  switch (bundlerType) {
    case 'vite':
      setupViteHMR(hot);
      break;
    case 'webpack':
    case 'rspack':
      setupWebpackHMR(hot, registry);
      break;
    default:
      // Use standard HMR setup
      setupStandardHMR(hot, registry);
      break;
  }

  return true;
}

const _$tmpl = template("<div>Count:</div>");
function SignalComponent() {
  const count = signal(0);
  return (() => {
    const _$el = _$tmpl();
    const _$nodes = mapNodes(_$el, [1]);
    insert(_$nodes[0], () => count.value);
    _$nodes[0]["_$click"] = () => count.value++;
    return _$el;
  })();
}
SignalComponent.__signature = "dtx8aj";
SignalComponent.__hmrId = "35tyqe:SignalComponent";
createApp(createHMRComponent(SignalComponent), "#root");
delegateEvents(["click"]);
const __$registry$__ = [SignalComponent];
if (import.meta.hot) {
  hmrAccept("rollup", import.meta.hot, __$registry$__);
  import.meta.hot?.accept();
}
"
`;
